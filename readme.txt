1038  状态DP
1039  数学,模拟,线段相交
1049  模拟
1054  枚举+剪枝
1062  枚举条件+dijkstra
1066  多边形切割+dijkstra, 更简单方法枚举4条边界上的每个点,求目标点与该点线段相交最小数
1069  斜方向坐标+搜索
1084- 贪心,每次把最多正方形的公共边移除(贪心是错的)
1085  状态记忆搜索 最多2^18=262144状态 f[s]=当前状态前提下最佳策略能获得多少三角形 最优策略是1.能组成三角形全部组成.2.添加1根使对手能获得最多三角形的数量最小,即s->s1 f[s1]最小
1090  高精度,2进制. 初始res=0, 碰到i位为1(i从1开始) res = 2^i-1 - res
1091  高精度,容斥原理,数学
1099  模拟
1103  45度建图+DFS遍历
1104  逻辑控制
1105  二进制+模拟
1108  二叉树+模拟
1109  字符串处理+模拟+排序
1110  模拟,寻找1个像素=自己是像素,其他字符全都是. 如果没找到找2个像素=自己2个都是像素,其他不全是o
1114  表达式计算
1115  模拟
1117  数字关系+枚举
1119  字符串
1120  模拟
1121  模拟
1122  dijkstra输出路径(注意A到B有0的路)
1123  枚举
1124  BFS
1127  线段相交+Floyd(可以用并查集速度更快,要注意共线不相交的情况)
1128  拓扑排序+DFS
1135  模拟(可以用最短路加枚举边)
1136- 计算几何
1137  BFS
1139  DFS
1140  小数高精度模拟
1143  博弈+记忆化搜索
1145  建树,字符串处理,DFS
1150  排列数最后非0数字,同余,5要单独处理
1151  矩形并面积(x方向离散化+y方向线段树)
1153  环形上所有点到某一点绝对值之和最小
1155  树形dp
1161 以区域为点建图,相邻区域则连一条权重1的边(双向).志愿者所在城镇单独为节点,并到周围区域连权重0的边(单向),Floyd求最短路(用BFS可以N^2)
1165  搜索剪枝(注意转置矩阵副对角线会反)
1167  搜索剪枝(按个数排序,如果后续都为现在的num,数量还是不能比最优小,就不继续搜索了)
1169  枚举
1170  DP(记忆化搜索)
1172  DFS
1173  DP + 递归
1174  字符串,二进制统计
1176  枚举,二进制
1178  枚举,国际象棋,最短路floyd
1179  枚举+记忆化搜索(好题)
1180  dp+斜率优化(单调队列),O(n)<好题>
1185  状态dp(好题)
1188  立方体相交体积
1189  DP(记忆化搜索)
1190  搜索+剪枝
1191  方差,记忆化搜索
1192  DFS
1193  堆+链表,模拟
1194  DP+字符串匹配(暴力)
1195  二维树状数组(4叉树超时)
1198  双向BFS+hash
1200  hash
1202  DFS(记忆),高精度小数,概率
1204  Trie树
1205  递推+高精度
1209  模拟
1212  约瑟夫环
1214  模拟
1215  模拟(时间)
1216  模拟
1219  模拟
1220  高精度(进制转换)
1227  二分图,连通分量,dfs
1228  凸包
1229  DP
1231  并查集
1232  贪心(每次选能移除最多的)
1233  滚动数组递推或者BFS
1234  模拟
1235  3维连通分量(DFS)
1237  一笔画(欧拉路概念)+Dijkstra
1238  DP(类似于floyd   f[s][i][j] = i -> j 经过s步的最大值  f[s][i][j] = max(f[s-1][i][k] * f[1][k][j]),  f[1][i][j] = map[i][j]
1239  双向dp, 第一次:从前往后，找到符合条件的最小最后一个数。第二次：在最后一个数为第一次结果的前提下，从后往前找到符合条件的最大最前一个数
1240  组合数学+递归
1241  数学,二进制
1242  枚举
1245  模拟
1249  格式输出,枚举
1252  双向dp,或者BFS
1255  矩形切割,并查集,模拟
1257  建图,连通分量,欧拉路概念
1260  DP
1262  矩形交叉,几何,模拟
1264  凸包,叉积,点在凸包内,凸包面积
1265  Pick定理(S=I+E/2.0 - 1, S=面积 I内部点 E边缘点), gcd, 叉积求多边形面积
1270  DFS+拓扑排序
1277  数学(n个点用n条边连成一个环,最多有几个焦点. 奇数=隔n/2-1个点连一条边,每条边有(n/2-1)*2条边穿过它,一共n个顶点,但是每个交点有2条边被计算了2次,一共(n/2-1)*2*n/2=(n/2-1)*n条. 偶数可以将某2个相邻看成一个点,构成n-1顶点形态,最多有((n-1)/2-1)*n条边,最后2个相邻点可以交叉一次,多一个顶点,((n-1)/2-1)*n+1)
1278  DP
1280  2次DP,对每回合做dp,之后再对每场做dp
1281  模拟
1283  整数拆分(把n拆分成k个无序正整数拆分数 = 把n拆分成最大数为k的无序正整数拆分数 f[n][1] = 1 f[n][n] = 1 f[n][k] = sum(f[n-k][i]), i<=k)
1284  欧拉数,原根(奇质数)
1285  组合数学,母函数
1286  Polya定理
1289  数学+二分
1290  模拟
1291  并查集
1293  01背包DP(输出选择)
1295  DFS
1296  图像处理,模拟
1297  DP(滚动数组,id剪枝)
1304  模拟(周期)
1307  DFS+格式输出
1327  DFS+数学计算
1310  模拟
1312  高精度(字符串序号 类似于26进制)
1319  小球排列,枚举
1335  字符串序号(递归)
1339  nlogn哈夫曼树(堆)
1340  dijkstra
1341  线段树(最小值)
1342  模拟(图像处理min金字塔)
1343  树同构(叶子节点编码01,有子节点s1,s2,...sn,按升序排序,编码为0+s1+s2+...+sn+1),2棵树编码相同则为同构),并查集判断集合
1346  环形数组排序,最小需要调整多少个数(DP最长排序子串) + 枚举 (好题)
1348  全枚举
1349  排列数序数(高精度) 模板
1351  记忆化搜索(DP)
1352  模拟
1353  模拟
1355  模拟
1356  枚举所有可能的xy点对做起点
1358  DP+网络流.  先用dp求出每个土地去除某个字母是否能找到h*w的矩形,可以就从字母到该土地连一条流量为1的边,原点到每个字母连一条流量为1的边,原点到不去除字母的点连一条无限大的边,每个土地到汇点连一条流量为1的边,求原点到汇点的最大流
1359  枚举
1362  偏2进制(模拟)
1365  质数模拟
1366  找循环节+bit操作
1367  日历
1370  枚举+并查集, ax+b=cy+d整数解条件 = abs(b-d)%gcd(a,c) == 0
1371  离散化+DFS
1374  格式化输出
1375  数学求解
1376  BFS
1377  数学
1378  hash+模拟
1385  多边形重心
1387  积分图+暴力n^4
1388  关键点(floyd思想,k为关键点)
1389  矩形并面积(离散化+线段树)
1390  记忆化搜索(祖玛), DP, 刘汝佳
1391  模拟(图论)
1392  搜索
1394  2遍dijkstra,第一遍找到最早达到时间,第二遍反推最晚出发时间
1395  用标志位记录能否计算出k(BFS?DP?), 看是否a*x, b*x可以被计算出来
1396  高精度模拟(注意----的对其)
1398  对给定的一个g(n)序列，如果g(n)是关于n的多项式，则满足以下性质：相邻两个两两相减，得到一个长度n-1的新序列，对新序列重复减法，在经过有限步重复操作后，总会得到一个全是0的序列。此题要求最大幂最小的多项式，就是使重复减法的次数最少，也就是最早出现“序列的每个数都相等”。对题目中给的s个数，经过s-1次重复减法后，会得到一个数，在其后添加c个这个数，然后去求第s-1行的剩下c个数，其实就是执行上述重复减法操作的逆操作，直到回推到第一个序列！
1400  去无效括号:建树,之后中序遍历输出
1407  模拟+格式化输出
1408  线段交点,多边形面积
1409  DFS
1413  模拟球队排名(编程复杂)
1414  枚举
1415  图论(栈处理)注意只有1个门的房间,进去就退出,然后要判断一次出栈
1417  并查集(真假话)+DP
1419  DFS(也可用最大团)
1420  求表格值(递归)
1425  组合数学 L个点全联通
      求：F1 所有长度小于等于L路径的均长，途径的点、边全都可以重复
          F2 所有简单路径的均长，途径的点、边都不可以重复
          F3 所有简单回路的均长，除首尾两点必然重复，途径的点、边不可以重复
1430  第2类斯特林数的奇偶性，转化为C(n,m)的奇偶性来做
1431  枚举
1432  DP, f[i]可以的话,匹配每个单词，如果匹配成功则f[i+L[k]] += f[i],最后结果为f[Ls]
1434  2分枚举答案,看看是否可行
1436  线段树覆盖
1437  模拟，注意morn than(>)
1440  DP(记忆化搜索)
1441  字符串处理(需要用uint8不然会wa)
1442  有2个操作1插入队列，2求队列中第k小数。使用2个堆来维护队列，大根堆储存前k最小数，小根堆储存后面的数。
1443  贪心,制造一个尽可能只匹配删除的字串(第k位都一样则用这个字符，如果有不同则用？，如果某个已经结束，另外没结束加上*)，然后再用这个字符串匹配不需要删除的，如果能匹配，则impossible，否则输出结果
1444  长方体表面积上2点最短距离，看解题，先将点旋转到下面，然后递归展开求解
1703  并查集
1742  DP
1789  最小生成树prim
1797  dijkstra
2139
2229
2376
2393
2431
2718
3040
3050
3169
3176
3187
3190
3253
3255
3259
3262
3616
3617
3669