 二分图匹配――匈牙利算法

二分图匹配的一种方案是由网络流算法转化而来。对于二分图G=<V1,V2,E>，先

设一个源点s和一个终点t，设s与V1中每一个点邻接，且t与V2中每一个点邻接，

再设E中每条边的权为1。这时，求由s到t的最大流即可。


用网络流算法求二分图匹配的问题主要在于，程序复杂、难于调试，且不易保存具

体的匹配方案。于是就有了在网络流算法基础上简化、改进得到的算法。

（通常使用的匈牙利算法本质上是基于宽度优先搜索的增广路网络流算法，不过我

一直使用的是基于深度优先搜索的算法。有资料也把这种算法称作匈牙利算法）


匹配算法的C语言实现如下：


以下内容为程序代码:


/*


设二分图两部分大小分别为m、n，map[m][n]为图的邻接矩阵


match[m]存储了匹配的方案，初始值为n


chk[m]记录点是否被扫描过,res储存匹配数


*/


int Dfs(int p)
{
int i , t;
	for (i = 0; i < m; i ++)
		if (map[i][p] && !chk[i])
		{
			chk[i] = 1;
			t = match[i];
			match[i] = p;
			if(t == n || Dfs(t))return 1;
			match[i] = t;
		}
	return 0;
}

int maxmatch()
{
int i , res = 0;

	for (i = 0; i < m; i ++) match[i] = n;
	for (i = 0; i < n; i ++)
	{
		memset(chk , 0 , sizeof(chk));
		if (Dfs(i))
		res ++;
	}
	return res;
}




设搜索增广路算法的时间复杂度为O(e)，易知最坏情况下，e与图的大小N的关系是一

次的，所以算法的时间复杂度应为O(N^2)。
 
